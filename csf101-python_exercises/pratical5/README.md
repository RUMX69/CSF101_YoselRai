Practical 5 Documentation & Reflection
Instructions
For this practical, we were required to:

Implement a Binary Search Tree (BST) in Python, including node insertion, searching, deletion, and traversals (in-order, pre-order, post-order).
Implement a Graph using an adjacency list, and perform Depth-First Search (DFS) and Breadth-First Search (BFS) traversals.
Use object-oriented programming principles to encapsulate tree and graph behaviors.
Write and run test code to demonstrate and verify each operation.

Reflection
What I Learned
Gained practical experience implementing binary search trees and graphs from scratch using Python classes.
Learned how to perform and implement tree traversals (in-order, pre-order, post-order) and graph traversals (DFS and BFS).
Improved my understanding of object-oriented programming and encapsulation for data structures.
Understood the importance of handling edge cases, such as deleting nodes with two children in BSTs or traversing disconnected graphs.
Challenges Faced and How I Overcame Them
BST Deletion Logic:
Handling deletion of nodes with two children was tricky. I reviewed the algorithm and used helper functions to find the minimum value in the right subtree.
Graph Traversal Bugs:
Initially, my DFS and BFS implementations revisited nodes or missed some. I fixed this by carefully managing the visited set.
Testing and Debugging:
Used print statements and step-by-step tracing to verify the correctness of insertions, deletions, and traversals.

This practical strengthened my understanding of tree and graph data structures, traversal algorithms, and object-oriented programming in Python. The process of implementing, testing, and debugging these structures has prepared me for more advanced algorithmic challenges.