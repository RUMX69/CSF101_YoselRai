Practical 3 Reflection
Instructions
For this practical, we were required to:

Implement the Queue and Stack data structures from scratch using Python classes.
Practice core operations for each data structure:
For Queue: enqueue, dequeue, is_empty, front, and size.
For Stack: push, pop, is_empty, peek, and size.
Add error handling for invalid operations (e.g., popping from an empty stack or dequeuing from an empty queue).
Write test code to demonstrate and verify the correct behavior of each data structure.

Reflection
What I Learned
Gained hands-on experience implementing fundamental data structures (queue and stack) from scratch.
Practiced object-oriented programming concepts such as class definitions, constructors, and instance methods.
Understood the importance of robust error handling for invalid operations.
Learned to test and verify each method to ensure correct behavior.
Challenges Faced and How I Overcame Them
Handling Empty Data Structures:
Initially, I forgot to handle cases where pop, dequeue, peek, or front were called on empty structures, which caused runtime errors. I fixed this by adding checks and raising descriptive exceptions.
Testing All Operations:
Ensured that all methods worked as expected by writing test cases for each operation and checking outputs.
Naming Conventions:
Noticed that class names should follow the CamelCase convention (e.g., Stack instead of stack). I kept the original naming for consistency with the code provided, but will follow conventions in future projects.
This practical improved my understanding of data structures, object-oriented programming, and robust error handling in Python. The process of testing and refining the implementation helped reinforce these concepts and prepared me for more complex data structure challenges.